<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Card Gallery</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@3"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">

<div id="app" class="p-8">

  <h1 class="text-4xl font-bold mb-6 text-center">
    Card Gallery {{ cardsVersion }}
  </h1>

  <!-- Sticky toolbar (banner + filters + guild chips) -->
  <div class="sticky top-0 z-30 -mx-8 -mt-8 px-8 py-2 bg-gray-100/95 backdrop-blur border-b">

    <!-- Nommsters banner (lean, always-visible) -->
    <a
      href="nommsters.html"
      class="mb-2 flex items-center justify-center gap-2 rounded-md border bg-white px-2 py-1 text-sm font-semibold text-gray-900 hover:border-blue-400 hover:shadow-sm transition"
    >
      <span class="text-gray-500 font-normal">Nommsters:</span>
      <span class="truncate">Choose your Nommster</span>
      <span class="text-blue-600">â†’</span>
    </a>

    <!-- Mobile: toggles row (Filters + Guilds) -->
    <div class="sm:hidden flex justify-center gap-2 mb-2">
  
      <button
        @click="showMobileGuilds = !showMobileGuilds"
        class="px-3 py-1 text-sm rounded-md border bg-white shadow-sm flex items-center gap-2"
      >
        Guilds
        <span
          class="inline-block transition-transform"
          :class="showMobileGuilds ? 'rotate-180' : ''"
        >â–¼</span>
      </button>

      <button
        @click="showMobileFilters = !showMobileFilters"
        class="px-3 py-1 text-sm rounded-md border bg-white shadow-sm flex items-center gap-2"
      >
        More filters
        <span
          class="inline-block transition-transform"
          :class="showMobileFilters ? 'rotate-180' : ''"
        >â–¼</span>
      </button>

    </div>



    <!-- Mobile: collapsible filters (ONLY on small screens) -->
    <div v-if="showMobileFilters" class="sm:hidden mb-2">
      <div class="flex flex-col gap-2 bg-white border rounded-md p-2 shadow-sm">

        <select v-model="selectedType" class="w-full px-2 py-1 text-sm rounded border">
          <option value="">All Types</option>
          <option v-for="type in types" :key="type">{{ type }}</option>
        </select>

        <select v-model.number="selectedRarity" class="w-full px-2 py-1 text-sm rounded border">
          <option :value="null">All Rarities</option>
          <option v-for="r in rarityOptions" :key="r.value" :value="r.value">
            {{ r.label }}
          </option>
        </select>

        <input
          v-model="searchQuery"
          type="text"
          placeholder="Search (name, traits, effects, rarityâ€¦)"
          class="w-full px-2 py-1 text-sm rounded border"
        />

        <label class="flex items-center text-sm">
          <input type="checkbox" v-model="showFavoritesOnly" class="mr-2">
          Only show favorites
        </label>

      </div>
    </div>

    <!-- Desktop: filters always visible (sm and up) -->
    <div class="hidden sm:flex flex-wrap items-center justify-center gap-2 mb-2">

      <button
        @click="toggleDeckView"
        class="hidden sm:inline-flex px-3 py-1 text-sm bg-blue-500 text-white rounded shadow-sm"
      >
        {{ showDeck ? "Back to Gallery" : `View My Deck (${deckSize})` }}
      </button>

      <select v-model="selectedType" class="px-2 py-1 text-sm rounded border">
        <option value="">All Types</option>
        <option v-for="type in types" :key="type">{{ type }}</option>
      </select>

      <select v-model.number="selectedRarity" class="px-2 py-1 text-sm rounded border">
        <option :value="null">All Rarities</option>
        <option v-for="r in rarityOptions" :key="r.value" :value="r.value">
          {{ r.label }}
        </option>
      </select>

      <input
        v-model="searchQuery"
        type="text"
        placeholder="Search (name, traits, effects, rarityâ€¦)"
        class="px-2 py-1 text-sm rounded border"
      />

      <label class="flex items-center text-sm">
        <input type="checkbox" v-model="showFavoritesOnly" class="mr-2">
        Only show favorites
      </label>
    </div>

    <!-- Guild Filter Buttons with Dynamic Colors -->
    <div
      class="flex flex-wrap gap-2 justify-center"
      :class="showMobileGuilds ? '' : 'hidden sm:flex'"
    >
      <button
        v-for="guild in guilds"
        :key="guild"
        @click="toggleGuild(guild)"
        class="px-2 py-3.5 text-sm rounded-full border shadow-sm flex items-center gap-2 transition-all"
        :style="{
          backgroundColor: selectedGuilds.includes(guild) ? guildColors[guild] : '#e5e5e5',
          color: selectedGuilds.includes(guild) ? 'white' : 'black'
        }"
      >
        <input
          type="checkbox"
          :checked="selectedGuilds.includes(guild)"
          class="w-3.5 h-3.5 pointer-events-none"
        >
        {{ guild }}
      </button>
    </div>

  </div>

  <!-- Full Image Modal: Move It Here So It Stays Visible Across Views -->
  <div v-if="showModal" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50" @click="closeModal">
    <div class="relative p-4 bg-white rounded shadow-lg max-w-screen-md" @click.stop>
      <!-- Close Button -->
      <button @click="closeModal" class="absolute top-2 right-2 text-gray-600 text-2xl">&times;</button>
      <!-- Full-size Image -->
      <img :src="'./' + modalImage" class="max-w-full h-auto rounded">
    </div>
  </div>

  <!-- Deck Drawer Backdrop -->
  <div
    v-if="showDeck"
    class="fixed inset-0 z-40 bg-black bg-opacity-40"
    @click="toggleDeckView"
  ></div>

  <!-- Deck Drawer Panel -->
  <div
    class="fixed top-0 right-0 h-full w-[92vw] sm:w-[420px] md:w-[520px] z-50 bg-white shadow-2xl transform transition-transform duration-200 ease-out"
    :class="showDeck ? 'translate-x-0' : 'translate-x-full'"
  >
    <!-- Header -->
    <div class="flex items-center justify-between p-4 border-b">
      <div class="font-semibold text-lg">My Deck ({{ deckSize }})</div>
      <button @click="toggleDeckView" class="text-2xl leading-none text-gray-600">&times;</button>
    </div>

    <!-- Actions -->
    <div class="p-4 flex gap-2">
      <button
        @click="openDeckCodeModal"
        class="px-3 py-2 bg-green-600 text-white rounded shadow"
      >
        Generate Deck Code
      </button>

      <button
        @click="clearDeck"
        class="px-3 py-2 bg-red-600 text-white rounded shadow"
      >
        Delete My Deck
      </button>
    </div>

    <!-- Content -->
    <div class="p-4 overflow-y-auto h-[calc(100%-120px)]">
      <div v-if="myDeckCards.length === 0" class="text-gray-500 text-sm">
        Your deck is empty. Add cards from the gallery.
      </div>

      <div v-else class="grid gap-2 grid-cols-[repeat(auto-fit,minmax(250px,1fr))] justify-center">
        <div v-for="card in myDeckCards" :key="card.id" class="bg-white p-2 rounded shadow relative w-[250px]">

          <img
            :src="card.thumbnail ? './' + card.thumbnail : './' + card.image"
            class="max-w-[225px] h-auto rounded cursor-pointer"
            :alt="card.name"
            @click="openModal(card.image)"
            loading="lazy"
          >

          <h2 class="text-xl font-semibold mt-2">{{ card.name }}</h2>
          <p class="text-sm text-gray-500">{{ card.guild }} | {{ card.type }} | {{ card.rarityLabel }}</p>

          <div class="mt-2 text-sm">
            <span>In my deck &gt; </span>
            <span
              v-for="count in getMaxCopies(card.rarity)"
              :key="count"
              @click="setDeckCount(card.id, count)"
              class="px-2 py-1 cursor-pointer rounded"
              :class="{
                'bg-blue-500 text-white': count !== 0 && getDeckCount(card.id) === count,
                'bg-gray-500 text-white': count === 0 && getDeckCount(card.id) === 0,
                'bg-gray-200 text-gray-800': getDeckCount(card.id) !== count
              }"
            >
              {{ count }}
            </span>
          </div>

          <button
            @click="toggleFavorite(card.id)"
            class="absolute top-2 right-2 text-6xl"
            :class="isFavorite(card.id) ? 'text-red-400' : 'text-gray-300'"
          >
            â™¥
          </button>

        </div>
      </div>
    </div>
  </div>

  <!-- Card Gallery or My Deck -->
  <div v-if="loading" class="text-center text-gray-500">Loading cards...</div>

  <!-- Deck Code Popup -->
  <div v-if="showDeckCodeModal" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-50" @click="closeDeckCodeModal">
    <div class="relative p-4 bg-white rounded shadow-lg max-w-screen-md text-center" @click.stop>

      <!-- Close Button -->
      <button @click="closeDeckCodeModal" class="absolute top-2 right-2 text-gray-600 text-2xl">&times;</button>

      <!-- Deck Code Title -->
      <h2 class="text-2xl font-semibold mb-4">Your Deck Code</h2>

      <!-- Deck Code Content -->
      <pre class="p-4 bg-gray-200 rounded text-sm whitespace-pre-wrap select-all text-left leading-snug">{{ deckCode }}</pre>

      <!-- Copy to Clipboard Button -->
      <button
        @click="copyDeckCode"
        :disabled="copied"
        class="mt-4 px-4 py-2 rounded shadow"
        :class="copied ? 'bg-gray-400 text-white cursor-not-allowed' : 'bg-blue-500 text-white cursor-pointer'"
      >
        {{ copied ? "Copied!" : "Copy to Clipboard" }}
      </button>

    </div>
  </div>

  <!-- Regular Gallery View -->
  <div class="grid gap-2 grid-cols-[repeat(auto-fit,minmax(250px,1fr))] sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 justify-center">
    <div v-for="card in filteredCards" :key="card.id" class="bg-white p-2 rounded shadow relative w-[250px]">

      <img
        :src="card.thumbnail ? './' + card.thumbnail : './' + card.image"
        class="max-w-[225px] h-auto rounded cursor-pointer"
        :alt="card.name"
        @click="openModal(card.image)"
        loading="lazy"
      >

      <h2 class="text-xl font-semibold mt-2">{{ card.name }}</h2>
      <p class="text-sm text-gray-500">{{ card.guild }} | {{ card.type }} | {{ card.rarityLabel }}</p>

      <div class="mt-2 text-sm">
        <span>In my deck &gt; </span>
        <span
          v-for="count in getMaxCopies(card.rarity)"
          :key="count"
          @click="setDeckCount(card.id, count)"
          class="px-2 py-1 cursor-pointer rounded"
          :class="{
            'bg-blue-500 text-white': count !== 0 && getDeckCount(card.id) === count,
            'bg-gray-500 text-white': count === 0 && getDeckCount(card.id) === 0,
            'bg-gray-200 text-gray-800': getDeckCount(card.id) !== count
          }"
        >
          {{ count }}
        </span>
      </div>

      <button
        @click="toggleFavorite(card.id)"
        class="absolute top-2 right-2 text-6xl"
        :class="isFavorite(card.id) ? 'text-red-400' : 'text-gray-300'"
      >
        â™¥
      </button>

    </div>
  </div>

  <!-- Floating Deck Button -->
  <button
    @click="toggleDeckView"
    class="fixed bottom-4 right-4 z-50 px-4 py-3 rounded-full shadow-lg text-white bg-blue-600"
  >
    {{ showDeck ? "Close Deck" : `Open Deck (${deckSize})` }}
  </button>

</div> <!-- END #app -->


<script>
const { createApp } = Vue;

createApp({
  data() {
    return {
      showMobileFilters: false,
      showMobileGuilds: false,
      cardsVersion: "", // â† will come from JSON
      copied: false, // âœ… Tracks if the button was clicked
      deckCode: "",  // Stores generated deck string
      deckCounts: Vue.reactive(JSON.parse(localStorage.getItem('deckCounts') || '{}')),
      selectedGuilds: [],
      isCompact: false,
      guildColors: {
        Axalon: "#1bb829",
        Burlindor: "#e28416",
        Coronis: "#ffef03",
        Flaria: "#ce9dde",
        Ziotech: "#2c4dea",
        Wildkind: "#c60757"
      },
      selectedType: '',
      selectedRarity: null,
      showFavoritesOnly: false,
      searchQuery: '',
      showDeck: false,
      myDeck: JSON.parse(localStorage.getItem('myDeck') || '[]'),
      cards: [],
      favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
      loading: true,
      showModal: false,
      modalCard: {},
      modalImage: '',
      showDeckCodeModal: false,  // âœ… Controls whether the popup is visible
    };
  },
  computed: {
    rarityOptions() {
      const seen = new Set();
      const opts = [];

      for (const card of this.cards) {
        if (card.rarity == null) continue;
        if (seen.has(card.rarity)) continue;
        seen.add(card.rarity);
        opts.push({
          value: card.rarity,
          label: card.rarityLabel || `Rarity ${card.rarity}`
        });
      }

      // Sort 1->3
      opts.sort((a, b) => a.value - b.value);
      return opts;
    },

    guilds() {
      return [...new Set(this.cards.map(card => card.guild))];
    },

    types() {
      return [...new Set(this.cards.map(card => card.type))];
    },

    rarities() {
      return [...new Set(this.cards.map(card => card.rarity))];
    },

    filteredCards() {
      if (this.selectedGuilds.length === 0) return [];

      const query = this.searchQuery
        .toLowerCase()
        .trim()
        .split(/\s+/)
        .filter(Boolean);

      return this.cards.filter(card => {
        if (!this.selectedGuilds.includes(card.guild)) return false;
        if (this.selectedType && card.type !== this.selectedType) return false;
        if (this.selectedRarity && card.rarity !== this.selectedRarity) return false;
        if (this.showFavoritesOnly && !this.isFavorite(card.id)) return false;

        // ðŸ”‘ SEARCH LOGIC
        if (query.length > 0) {
          const haystack = card.searchText || "";
          return query.every(token => haystack.includes(token));
        }

        return true;
      });
    },

    deckSize() {
      return Object.values(this.deckCounts).reduce((sum, count) => sum + count, 0);
    },

    myDeckCards() {
    return this.cards.filter(card => {
      const count = this.getDeckCount(card.id) || 0;
      return count > 0; // âœ… Only include cards with a count > 0
    });
  }

  },
  methods: {
    toggleGuild(guild) {
      if (this.selectedGuilds.includes(guild)) {
        // Remove guild from selection
        this.selectedGuilds = this.selectedGuilds.filter(g => g !== guild);
      } else {
        // Add guild to selection
        this.selectedGuilds.push(guild);
      }
    },
    onScroll() {
      this.isCompact = window.scrollY > 60;
    },
    clearDeck() {
      const ok = confirm("Delete your deck? This will remove all card counts.");
      if (!ok) return;

      // Clear all counts (this is what actually defines your deck)
      for (const key of Object.keys(this.deckCounts)) {
        delete this.deckCounts[key];
      }
      localStorage.setItem('deckCounts', JSON.stringify({}));

      // Optional cleanup: youâ€™re not really using this anymore
      this.myDeck = [];
      localStorage.setItem('myDeck', JSON.stringify([]));

      // Optional: close deck code modal if open
      this.showDeckCodeModal = false;
      this.copied = false;
      this.deckCode = "";
    },
    copyDeckCode() {
      if (!this.deckCode) return; // Prevent copying empty text

      navigator.clipboard.writeText(this.deckCode).then(() => {
        this.copied = true; // âœ… Button is now disabled and greys out
      }).catch(err => {
        console.error("Failed to copy: ", err);
      });
    },
    openDeckCodeModal() {
      this.generateDeckCode();  // Ensure deck code is generated before opening
      this.showDeckCodeModal = true;
    },
    closeDeckCodeModal() {
      this.showDeckCodeModal = false;
      this.copied = false; // âœ… Reset button state when closing modal
    },
    generateDeckCode() {
      const deckCards = this.cards.filter(card => this.getDeckCount(card.id) > 0);

      const groupedByGuild = {};
      deckCards.forEach(card => {
        if (!groupedByGuild[card.guild]) {
          groupedByGuild[card.guild] = [];
        }
        groupedByGuild[card.guild].push(`- ${card.name} x${this.getDeckCount(card.id)}`);
      });

      // --- Add selected Nommsters (from nommsters.html) ---
      let nommsterDeck = [];
      try {
        nommsterDeck = JSON.parse(localStorage.getItem('nommsterDeck') || '[]');
      } catch (e) {
        nommsterDeck = [];
      }

      nommsterDeck.forEach(n => {
        const guild = n.guild || 'Other';
        if (!groupedByGuild[guild]) groupedByGuild[guild] = [];

        // Put Nommster at the top of that guild section (feels â€œprimaryâ€)
        groupedByGuild[guild].unshift(`- Nommster: ${n.name}`);
      });


      // Add a forced newline before the deck code
      this.deckCode = "\n" + Object.entries(groupedByGuild)
        .map(([guild, cards]) => `${guild}\n${cards.join("\n")}`)
        .join("\n\n");

      console.log("Generated Deck Code:\n" + this.deckCode);
    },

    testClick(card) {
      console.log("Test Click Registered:", card.name);
      alert("You clicked on " + card.name);
    },

    getMaxCopies(rarity) {
      // Your encoding: 1=Rare, 2=Uncommon, 3=Common
      if (rarity === 1) return [0, 1];        // Rare max 1
      if (rarity === 2) return [0, 1, 2];     // Uncommon max 2
      return [0, 1, 2, 3];                    // Common max 3
    },


    setDeckCount(cardId, count) {
      this.deckCounts[cardId] = count;
      localStorage.setItem('deckCounts', JSON.stringify(this.deckCounts));
    },

    getDeckCount(cardId) {
      return this.deckCounts[cardId] ?? 0; // Default to 0 if not set
    },

    toggleDeckView() {
      this.showDeck = !this.showDeck;
      this.$nextTick(() => { 
        console.log("Updated myDeckCards:", this.myDeckCards);  // âœ… Ensure Vue updates
      });
    },

    toggleDeck(cardId) {
      if (this.myDeck.includes(cardId)) {
        this.myDeck = this.myDeck.filter(id => id !== cardId); // Remove from deck
      } else {
        this.myDeck.push(cardId); // Add to deck
      }
      localStorage.setItem('myDeck', JSON.stringify(this.myDeck));
    },

    isInDeck(cardId) {
      return this.myDeck.includes(cardId);
    },

    toggleFavorite(cardId) {
      if (this.favorites.includes(cardId)) {
        this.favorites = this.favorites.filter(id => id !== cardId);
      } else {
        this.favorites.push(cardId);
      }
      localStorage.setItem('favorites', JSON.stringify(this.favorites));
    },

    isFavorite(cardId) {
      return this.favorites.includes(cardId);
    },

    async fetchCards() {
      try {
        const response = await fetch('cards_v14.json');
        const data = await response.json();

        this.cardsVersion = data.version || "";
        this.cards = data.cards.sort((a, b) => {
          if (a.guild === b.guild) {
            return a.name.localeCompare(b.name);
          }
          return a.guild.localeCompare(b.guild);
        });
        
      } catch (error) {
        console.error("Error loading cards.json:", error);
      } finally {
        this.loading = false;  // Remove loading state
      }
    },

    openModal(image) {
      if (!image) {
        console.error("No image provided to openModal!");
        return;
      }
      console.log("Opening modal with image:", image);
      this.modalImage = image;
      this.showModal = true;
    },

    closeModal() {
      this.showModal = false;
      this.modalImage = '';
    }
  },

  mounted() {
    this.fetchCards().then(() => {
      this.selectedGuilds = [...this.guilds];
    });
  }
  


  
}).mount('#app');
</script>

</body>
</html>
