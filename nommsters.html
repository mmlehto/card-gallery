<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nommsters</title>
  <script src="https://unpkg.com/vue@3"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .flip-card {
      perspective: 1000px;
    }
    .flip-inner {
      transition: transform 0.4s;
      transform-style: preserve-3d;
    }
    .flipped .flip-inner {
      transform: rotateY(180deg);
    }
    .flip-front, .flip-back {
      backface-visibility: hidden;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .flip-back {
      transform: rotateY(180deg);
    }
    .modal-bg {
      background-color: rgba(0, 0, 0, 0.6);
    }
  </style>
</head>
<body class="bg-gray-100 p-6">
  <div id="app" class="max-w-5xl mx-auto">
    <h1 class="text-3xl font-bold text-center mb-2">Nommsters</h1>
    <div class="text-center mb-6">
      <a href="index.html" class="text-blue-600 hover:underline text-lg">&larr; Back to Gallery</a>
    </div>

    <!-- Filter Section -->

    <button 
      v-if="showDeck"
      @click="openDeckCodeModal" 
      class="px-4 py-2 bg-green-500 text-white rounded shadow mb-4">
      Generate Deck Code
    </button>

    <!-- Guild Filter Buttons with Dynamic Colors -->
    <div class="flex flex-wrap gap-2 justify-center mb-6">
      <button 
        v-for="guild in guilds" 
        :key="guild" 
        @click="toggleGuild(guild)"
        class="px-4 py-2 rounded border shadow flex items-center gap-2 transition-all"
        :style="{
          backgroundColor: selectedGuilds.includes(guild) ? guildColors[guild] : '#e5e5e5',
          color: selectedGuilds.includes(guild) ? 'white' : 'black'
        }">

        <!-- Non-Clickable Checkbox -->
        <input 
          type="checkbox" 
          :checked="selectedGuilds.includes(guild)" 
          class="w-4 h-4 pointer-events-none"
        >

        {{ guild }}
      </button>
    </div>

    <!-- Random Pick -->
    <div class="flex justify-center mb-6">
      <button
        @click="startRandomPick"
        :disabled="isPicking"
        class="px-4 py-2 bg-purple-600 text-white rounded shadow disabled:opacity-50"
      >
        {{ isPicking ? 'Picking…' : 'Pick a Random Nommster' }}
      </button>
    </div>

    <!-- Random Pick Overlay -->
    <div
      v-if="pickerOpen"
      class="fixed inset-0 flex items-center justify-center modal-bg z-50"
      @click="cancelPick"
    >
      <div class="bg-white p-5 rounded shadow-lg w-full max-w-md relative" @click.stop>
        <button class="absolute top-2 right-2 text-gray-600 text-xl font-bold" @click="cancelPick">&times;</button>

        <div class="text-lg font-semibold mb-3">Random pick in progress…</div>

        <div class="flex items-center gap-4">
          <div
            class="w-40 h-40 rounded border-4 overflow-hidden flex items-center justify-center"
            :style="{ borderColor: pickerCard ? guildColors[pickerCard.guild] : '#ddd' }"
          >
            <img
              v-if="pickerCard"
              :key="pickerCard.id"
              :src="pickerCard.front"
              class="w-full h-full object-contain nommsters-roulette-pop"
            />
            <div v-else class="text-gray-400">—</div>
          </div>

          <div class="flex-1">
            <div class="text-sm text-gray-500">Cycling through…</div>
            <div class="text-xl font-bold leading-tight">{{ pickerCard ? pickerCard.name : '—' }}</div>
            <div class="text-sm" :style="{ color: pickerCard ? guildColors[pickerCard.guild] : '#666' }">
              {{ pickerCard ? pickerCard.guild : '' }}
            </div>

            <div class="mt-4 h-2 bg-gray-200 rounded">
              <div class="h-2 bg-gray-800 rounded" :style="{ width: pickerProgress + '%' }"></div>
            </div>
            <div class="text-xs text-gray-500 mt-1">{{ Math.round(pickerProgress) }}%</div>
          </div>
        </div>

        <div class="mt-5 flex justify-end gap-2">
          <button @click="cancelPick" class="px-3 py-2 bg-gray-200 rounded">Cancel</button>
          <button @click="finishPickNow" class="px-3 py-2 bg-green-600 text-white rounded">Stop here</button>
        </div>
      </div>
    </div>


    <div v-for="card in filteredNommsters" :key="card.id" class="mb-8">
      <div class="flex items-center gap-6">
        <!-- Card flip container -->
        <div 
          class="relative w-64 h-64 flip-card cursor-pointer" 
          @click.left="openModal(card, flippedCards.includes(card.id))"
          :class="{ 'flipped': flippedCards.includes(card.id) }"
        >
        <!-- Flip Button (shared for both sides) -->
        <button
        @click.stop="toggleFlip(card.id)"
        class="absolute top-2 right-2 text-white text-4xl z-10"
        :style="{ backgroundColor: guildColors[card.guild] }"
        >
        &#x1F501;
        </button>
          <div class="flip-inner w-full h-full">
            <img :src="card.front" class="flip-front object-contain w-full h-full rounded border shadow">
            <img :src="card.back" class="flip-back object-contain w-full h-full rounded border shadow">
          </div>
        </div>

        <!-- Card Info -->
        <div>
          <h2 class="text-xl font-semibold mb-2">{{ card.name }}</h2>
          <div class="flex items-center gap-2 mb-3">
            <button
              class="px-3 py-1 rounded text-white"
              :style="{
                backgroundColor: !flippedCards.includes(card.id) ? guildColors[card.guild] : '#ccc',
              }"
              @click="setFlipped(card.id, false)"
            >Dormant</button>

            <button
              class="px-3 py-1 rounded text-white"
              :style="{
                backgroundColor: flippedCards.includes(card.id) ? guildColors[card.guild] : '#ccc',
              }"
              @click="setFlipped(card.id, true)"
            >Energized</button>
          </div>
          <button
            class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            @click="toggleDeck(card.id)"
          >
            {{ deck.includes(card.id) ? 'In My Deck' : 'Add to Deck' }}
          </button>
        </div>
      </div>
    </div>

    <!-- Modal -->
    <div v-if="modalCard" class="fixed inset-0 flex items-center justify-center modal-bg z-50" @click="closeModal">
      <div class="bg-white p-4 rounded shadow-lg max-w-xl w-full relative" @click.stop>
        <button class="absolute top-2 right-2 text-gray-600 text-xl font-bold" @click="closeModal">&times;</button>
        <img :src="modalState === 'dormant' ? modalCard.modalFront : modalCard.modalBack" class="w-full object-contain rounded">
      </div>
    </div>
  </div>

  <script src="nommsters-roulette.js"></script>

  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          nommsters: [],
          flippedCards: [],
          deck: [],
          modalCard: null,
          modalState: 'dormant',
          searchQuery: '',
          showFavoritesOnly: false,
          showDeck: false,
          selectedGuilds: [],
          guilds: ["Axalon", "Burlindor", "Coronis", "Flaria", "Sylvani", "Veralyn"],
          guildColors: {
            Axalon: "#1bb829",
            Burlindor: "#e28416",
            Coronis: "#ffef03",
            Flaria: "#ce9dde",
            Sylvani: "#2c4dea",
            Veralyn: "#c60757"
          },
          // random pick UI
          pickerOpen: false,
          isPicking: false,
          pickerCard: null,
          pickerProgress: 0,
          rouletteCancel: null,

        };
      },
      computed: {
        deckSize() {
          return this.deck.length;
        },
        filteredNommsters() {
          return this.nommsters.filter(card => {
            const inDeck = this.showDeck ? this.deck.includes(card.id) : true;
            const matchesSearch = card.name.toLowerCase().includes(this.searchQuery.toLowerCase());
            const isFavorite = this.showFavoritesOnly ? this.deck.includes(card.id) : true;
            const matchesGuild = this.selectedGuilds.length === 0 || this.selectedGuilds.includes(card.guild);
            return inDeck && matchesSearch && isFavorite && matchesGuild;
          });
        }
      },
      mounted() {
        fetch('nommsters_v13.json')
          .then(res => res.json())
          .then(data => {
            this.nommsters = data.sort((a, b) => {
              if (a.guild === b.guild) {
                return a.name.localeCompare(b.name);
              }
              return a.guild.localeCompare(b.guild);
            });

            this.selectedGuilds = [...this.guilds];
          })
          .catch(err => {
            console.error("Failed to load json", err);
          });
      },
      methods: {
        toggleFlip(id) {
          const isFlipped = this.flippedCards.includes(id);
          this.setFlipped(id, !isFlipped);
        },
        setFlipped(id, flipToBack) {
          const index = this.flippedCards.indexOf(id);
          if (flipToBack && index === -1) this.flippedCards.push(id);
          else if (!flipToBack && index !== -1) this.flippedCards.splice(index, 1);
        },
        toggleDeck(id) {
          const index = this.deck.indexOf(id);
          if (index === -1) {
            this.deck.push(id);
          } else {
            this.deck.splice(index, 1);
          }
        },
        toggleDeckView() {
          this.showDeck = !this.showDeck;
        },
        openModal(card, isFlipped) {
          this.modalCard = card;
          this.modalState = isFlipped ? 'energized' : 'dormant';
        },
        closeModal() {
          this.modalCard = null;
          this.modalState = 'dormant';
        },
        toggleGuild(guild) {
          const index = this.selectedGuilds.indexOf(guild);
          if (index === -1) this.selectedGuilds.push(guild);
          else this.selectedGuilds.splice(index, 1);
        },
        openDeckCodeModal() {
          const lines = this.nommsters
            .filter(c => this.deck.includes(c.id))
            .sort((a, b) => a.guild.localeCompare(b.guild))
            .map(c => `${c.name}`);

          const grouped = {};
          lines.forEach(line => {
            const [name] = line.split(' x');
            const guild = this.nommsters.find(c => c.name === name)?.guild || 'Other';
            if (!grouped[guild]) grouped[guild] = [];
            grouped[guild].push(line);
          });

          let output = '';
          for (const guild of Object.keys(grouped)) {
            output += guild + '\n';
            grouped[guild].forEach(line => output += ` - ${line}\n`);
          }

          navigator.clipboard.writeText(output.trim());
          alert("Deck code copied to clipboard!\n\n" + output.trim());
        },
        getPickPool() {
          // Picks from whatever is currently visible (respects your filtering):contentReference[oaicite:8]{index=8}
          return (this.filteredNommsters && this.filteredNommsters.length)
            ? this.filteredNommsters
            : this.nommsters;
        },
        startRandomPick() {
          if (this.isPicking) return;

          const pool = this.getPickPool();
          if (!pool.length) {
            alert("No Nommsters available to pick from.");
            return;
          }

          // reset UI
          this.isPicking = true;
          this.pickerOpen = true;
          this.pickerProgress = 0;
          this.pickerCard = pool[Math.floor(Math.random() * pool.length)];

          // cancel any previous run
          if (typeof this.rouletteCancel === "function") this.rouletteCancel();

          this.rouletteCancel = window.NommstersRoulette.runRoulette({
            pool,
            durationMs: 2600,
            onTick: (card) => { this.pickerCard = card; },
            onProgress: (p) => { this.pickerProgress = p; },
            onDone: (card) => {
              this.isPicking = false;
              this.pickerOpen = false;

              const isFlipped = this.flippedCards.includes(card.id);
              this.openModal(card, isFlipped); // uses your existing modal flow:contentReference[oaicite:9]{index=9}
            }
          });
        },
        cancelPick() {
          if (typeof this.rouletteCancel === "function") this.rouletteCancel();
          this.rouletteCancel = null;
          this.isPicking = false;
          this.pickerOpen = false;
          this.pickerProgress = 0;
        },
        finishPickNow() {
          if (typeof this.rouletteCancel === "function") this.rouletteCancel();
          this.rouletteCancel = null;

          const card = this.pickerCard;
          this.isPicking = false;
          this.pickerOpen = false;

          if (card) {
            const isFlipped = this.flippedCards.includes(card.id);
            this.openModal(card, isFlipped);
          }
        },

      }
    }).mount('#app');
  </script>
</body>
</html>